<<<<<<< HEAD
grammar org.eclipse.recommenders.snipeditor.SnipDSL with org.eclipse.xtext.xbase.Xbase
import "http://www.eclipse.org/xtext/xbase/Xtype"
=======
grammar org.eclipse.recommenders.snipeditor.SnipDSL with org.eclipse.xtext.xbase.Xbase 
>>>>>>> Test
import 'http://www.eclipse.org/xtext/xbase/Xbase' as xbase
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as types
import "http://www.eclipse.org/xtext/xbase/Xtype" as xtypes
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate snipDSL "http://www.eclipse.org/recommenders/snipeditor/SnipDSL"

domainmodel:
	importSection=XImportSection?
    (elements += abstractElement )*
;
<<<<<<< HEAD
XImportDeclaration :
=======
XImportDeclaration returns xtypes::XImportDeclaration:
>>>>>>> Test
	'${''import''('
	(
	importedType=[types::JvmDeclaredType|QualifiedName] 
		| importedNamespace=QualifiedNameWithWildcard
	)
	')}'
;


abstractElement returns xbase::XExpression:
	packageDeclare | 
	entity | 
	feature | 
	helpperClassAnnotation | 
	XExpressionInsideBlock 
;

packageDeclare:
	'package' name = QualifiedName '{'
	(elements += abstractElement)*
	'}'
;


entity:
	(visibility=Visibility)? 'class' name = ValidID 
		('extends' jType=abstractTypeName  )?
	'{'
		features += feature*
	
	'}'
;

feature returns xbase::XExpression:
	attributeDeclaration ";" | method 

;

method:
	(visibility=Visibility)? 'static'?  (jType=abstractTypeName | "void")
	name=ValidID'('(params+=FullJvmFormalParameter
		(','params+=FullJvmFormalParameter)*)?')' 
		('throws' throwExceptions+=operandID(',' throwExceptions+=operandID)*)?
	body=XBlockExpression
;
//attribute assignments
attributeAssignment returns xbase::XExpression:
	 blockAssignment | XLiteral |=>XExpression
;
//assignment with {...}
blockAssignment returns xbase::XExpression:
	{blockAssignment}
	"{" (values+=XLiteral (',' values+=XLiteral)*)? "}"
;


//attribute declaration
attributeDeclaration :
<<<<<<< HEAD
	(visible=Visibility)? 'static'? (jType=abstractTypeName)
<<<<<<< HEAD
	name = declarativeID ('=' value=attributeAssignment)? 
=======
=======
	(visible=Visibility)? 'static'? (jType=abstractTypeName | "${"ValidID"}" closure?=XClosure)
>>>>>>> Test
	name = declarativeID ('=' value=XExpression)? 
>>>>>>> Test
;

//features that are present in the block
XExpressionInsideBlock  returns xbase::XExpression :
 			(XVariableDeclaration | 
 			 XExpression | 
 			 UnaryOperation|
 			 myCastedExpression |
			 jFaceSpecificLiteral
<<<<<<< HEAD
<<<<<<< HEAD
 			)
;

abstractAssignmentOperation:
	operandAssignment | unaryOperation
;

operandAssignment:
	result=simpleOperand valueAssignmentOperator
		value=multyAssignOperation
;
//does not support ()
multyAssignOperation :

	operands+= (XFeatureCall | literal | XParenthesizedExpression) 
		(binaryOperator operands+=multyAssignOperation)*
	
;
unaryOperation:
	result=XFeatureCall
		operator=unaryOperator
	;

//removed =>, see what happens
conditionalExpression:
	
	('('operands+=operandAssignment')' 
		conditionOperator operands+=multyAssignOperation
	| operands+=multyAssignOperation
	 	(conditionOperator operands+=multyAssignOperation)?)
	
	(('&&' | '||')expressions+=conditionalExpression)*
;




XVariableDeclaration:
	jType=abstractTypeName
	name=declarativeID ('=' value = attributeAssignment)?
;
converssionCall:
	'('newJType=abstractTypeName')'name=XFeatureCall
	(arguments+=squareClosure)?
;

calledParameter returns xbase::XExpression:
	
	(localMethodCall | simpleOperand | XConstructorCall | converssionCall) 
;

XFeatureCall returns XExpression:
	featureCalls+=calledParameter
	(('.' featureCalls+=calledParameter)*) 
	
;


//this is the call for a method; has multyAssignOp as parameter as it includes all.
localMethodCall:
	name = operandID '('
	(parameters+=multyAssignOperation (',' parameters+=multyAssignOperation)*)?
	')' (arguments+=squareClosure)?
;
simpleOperand:
	name = (operandID) 	
	(arguments+=squareClosure)?
=======
 			) 
>>>>>>> Test
=======
 			) ';'?
>>>>>>> Test
;

XExpression returns xbase::XExpression :
	AssignmentWithClosure | XAssignment
;
/*
 *Assignment that changes the XAssignment to support [] closure 
 * for operands.
 * Does not offer scoping for local scope variables (variables inside a method body)
 * TODO: Implement JvmIdentifiableElement as feature!
 */
AssignmentWithClosure returns xbase::XExpression:
	{AssignmentWithClosure}
	(feature=FeatureCallID 
	closure=XClosure (OpSingleAssign|OpMultiAssign) value=XAssignment
	) 
;

/*
 * Note: Writable means final!
 * 
 */
XVariableDeclaration returns xbase::XExpression:
	{xbase::XVariableDeclaration}

	( writeable?='final')? (type=abstractTypeName) name=declarativeID ('=' right=attributeAssignment)?;

UnaryOperation returns xbase::XExpression:
	{UnaryOperation}
	operand=operandID feature=OpUnary
;



XPrimaryExpression returns xbase::XExpression:
	XConstructorCall |
	XBlockExpression |
	XSwitchExpression |
	AbstractFeatureCall |
	XLiteral |
	XIfExpression |
	ForLoopExpression |
	XWhileExpression |
	XDoWhileExpression |
	XThrowExpression |
	XReturnExpression |
	XTryCatchFinallyExpression |
	XParenthesizedExpression;


AbstractFeatureCall returns xbase::XExpression:
	FeatureCallWithClosure |
	XFeatureCall
;

/*
 * Feature call that supports [] closure
 */
FeatureCallWithClosure:
	feature=XFeatureCall closure=XClosure
;

<<<<<<< HEAD
XSwitchExpression returns XExpression:
	{XSwitchExpression}
	'switch' (=>(localVarName=typeID ':')? switch=XFeatureCall
		| =>('(' localVarName=typeID ':') switch=XFeatureCall ')') '{'
	(cases+=XCasePart 'break;')+
	('default' ':' defaultExp+=blockFeature* 'break;')?
	'}';

XCasePart:
	typeGuard=JvmTypeReference? ('case' case=XExpression)? 
		':' thenExp+=blockFeature
		 
		;
 
XForLoopExpression returns XExpression:
	
	classicForLoop | forLoopWithIterator
	;

classicForLoop:
	
	'for' '(' declaredParam=(XVariableDeclaration | simpleOperand) ';' 
				forExpression=conditionalExpression ';'
				forOperation=abstractAssignmentOperation ')'
		body=myBlockExpression
;

forLoopWithIterator:
	'for''('
		jType=(abstractTypeName) iteratorName=declarativeID ':'
		iteratableObject=XFeatureCall
		
	')'
	body=myBlockExpression
;



XWhileExpression returns XExpression:
	{XWhileExpression}
	'while' '(' predicate=conditionalExpression ')'
		body=myBlockExpression;
	
XDoWhileExpression returns XExpression:
	{XDoWhileExpression}
   'do'
       body=myBlockExpression
   'while' '(' predicate=conditionalExpression ')';


//TODO: replace ValidID to support abstract type creation
XConstructorCall returns XExpression:
	{XConstructorCall}
	'new' constructor=abstractTypeName 
	(=>'<' typeArguments+=abstractTypeName (',' typeArguments+=abstractTypeName)* '>')?
	(=>'(' 
=======
XConstructorCall returns xbase::XExpression:
	{xbase::XConstructorCall}
	'new' constructor=[types::JvmConstructor|operandID] 
	(=>'<' typeArguments+=JvmArgumentTypeReference (',' typeArguments+=JvmArgumentTypeReference)* '>')?
	((=>'(' 
>>>>>>> Test
		(
		    arguments+=XShortClosure
		  |	arguments+=XExpression (',' arguments+=XExpression)*
		)? 
	')') |=> arguments+=XClosure);

/*
 * Overridden to eliminate lambda expression 
 * This expressions were conflicting with [] closure, and java has no lambda expressions
 */
XFeatureCall returns xbase::XExpression:
	{xbase::XFeatureCall}
	('<' typeArguments+=JvmArgumentTypeReference (',' typeArguments+=JvmArgumentTypeReference)* '>')? 
	feature=[types::JvmIdentifiableElement|IdOrSuper] 
	(=>explicitOperationCall?='(' 
		(
		    featureCallArguments+=XShortClosure
		  |	featureCallArguments+=XExpression (',' featureCallArguments+=XExpression)*
		)? 
	')')?
	;


/*
XMemberFeatureCall returns xbase::XExpression:
	XPrimaryExpression
	(=>({xbase::XAssignment.assignable=current} ('.'|explicitStatic?="::") feature=[types::JvmIdentifiableElement|FeatureCallID] OpSingleAssign) value=XAssignment
	|=>({xbase::XMemberFeatureCall.memberCallTarget=current} ("."|nullSafe?="?."|explicitStatic?="::")) 
		('<' typeArguments+=JvmArgumentTypeReference (',' typeArguments+=JvmArgumentTypeReference)* '>')?  
		feature=[types::JvmIdentifiableElement|FeatureCallID] (
			=>explicitOperationCall?='(' 
				(
				    memberCallArguments+=XShortClosure
				  |	memberCallArguments+=XExpression (',' memberCallArguments+=XExpression)*
				)? 
			')')?
		)*;
*/

myCastedExpression:
 '(' type=abstractTypeName ')' target=XExpression
;


ForLoopExpression returns xbase::XExpression:
	ClassicForLoopExpression | XForLoopExpression
;


OpUnary:
	"!" | "--" | "++";


ClassicForLoopExpression:
	//{ClassicForLoopExpression}
	'for' '(' 
	declaredParam=JvmFormalParameter ('=' value=XAssignment)?';' 
				condition=XExpression ';' 
				(forExpression=XExpression | forExpression=UnaryOperation)
		')'
		eachExpression=XExpression
;



XForLoopExpression returns xbase::XExpression:
	{xbase::XForLoopExpression}
	'for' '(' declaredParam=(FullJvmFormalParameter|JvmFormalParameter) ':' forExpression=XExpression ')'
		eachExpression=XExpression
;

enum Visibility :
	 protected | public | private
;

<<<<<<< HEAD
//TODO: put abstract type in elemType!
<<<<<<< HEAD
 typeID:
 	{typeID}
 		('${'ValidID 
			(=>':''elemType' '('type=JvmTypeReference')}' | '}'))
 		|(=>'${''elemType' '('type=JvmTypeReference')}')
=======
=======
>>>>>>> Test
 typeID returns types::JvmTypeReference:
 		('${'ValidID':''elemType' '('=>JvmTypeReference')}')
 		|(=>'${''elemType' '('=>JvmTypeReference')}')
>>>>>>> Test
 ;

declarativeID:
	  jFaceVarID |
	  =>ValidID 
;

jFaceVarID:
	'${'ValidID'}' 
		|('${'=>ValidID ':' ('freeName'|'newName') '('ValidID')}')
 		|('${'=>('freeName'|'newName') '('ValidID')}')
;
operandID :
<<<<<<< HEAD
	 
	ValidID | 
	 ('${' ValidID ':''var''}') 
	 |=>'${'ValidID'}'
=======
	ValidID | 
<<<<<<< HEAD
	('${' (ValidID) (':''var')? '}') 
>>>>>>> Test
=======
	('${' (=>ValidID) (':''var')? '}')

>>>>>>> Test
;


jFaceSpecificLiteral:
	'${'type=('cursor'|'dollar'|'line_selection')'}'
;

<<<<<<< HEAD
abstractTypeName :
	(typeID) '[]'? 
	|=>	type=JvmTypeReference '[]'?
=======
abstractTypeName returns types::JvmTypeReference:
	(typeID)  
	|=>	JvmTypeReference
;
FeatureCallID:
	operandID | 'extends' | 'static' | 'import' | 'extension'
>>>>>>> Test
;
JvmFormalParameter returns types::JvmFormalParameter:
	(parameterType=abstractTypeName)? name=operandID;
	
FullJvmFormalParameter returns types::JvmFormalParameter:
	(parameterType=abstractTypeName | '${'ValidID'}') name=(declarativeID|operandID) ;


<<<<<<< HEAD


/* 
annotation :
	
	'${cursor}' | '${dollar}'
		
;*/
=======
>>>>>>> Test
helpperClassAnnotation :
	'${' 'helper' '}' 
	class= entity 
	'${' 'endHelper' '}'
;
XLiteral returns xbase::XExpression:
	XBooleanLiteral |
	XNumberLiteral |
	XNullLiteral |
	XStringLiteral
;
terminal ID:
	'^'? ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
	

 