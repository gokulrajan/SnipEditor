grammar org.eclipse.recommenders.snipeditor.SnipDSL with org.eclipse.xtext.xbase.Xbase
import 'http://www.eclipse.org/xtext/xbase/Xbase' as xbase
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as types

generate snipDSL "http://www.eclipse.org/recommenders/snipeditor/SnipDSL"

domainmodel:
	(importSection+=importDeclare)*
    (elements += abstractElement )*
;
importDeclare :
	'${''import''('name = (QualifiedNameWithWildcard | QualifiedName) ')}'
;


abstractElement returns xbase::XExpression:
	packageDeclare | 
	entity | 
	feature | 
	helpperClassAnnotation | 
	XAssignment ";" | 
	XPrimaryExpression ";"?|
	jFaceSpecificLiteral
;

packageDeclare:
	'package' name = QualifiedName '{'
	(elements += abstractElement)*
	'}'
;


entity:
	(visibility=Visibility)? 'class' name = ValidID 
		('extends' jType=abstractTypeName  )?
	'{'
		features += feature*
	
	'}'
;

feature:
	attributeDeclaration ";" | method 

;
//attribute declaration
attributeDeclaration :
	(visible=Visibility)? 'static'? (jType=abstractTypeName)
	name = declarativeID ('=' value=attributeAssignment)? 
;

parameter returns types::JvmFormalParameter:
	parameterType = JvmTypeReference  name = declarativeID;


method:
	(visibility=Visibility)? 'static'?  (jType=abstractTypeName| "void")
	name=ValidID'('(params+=parameter
		(','params+=parameter)*)?')' 
		('throws' throwExceptions+=simpleOperand(',' throwExceptions+=simpleOperand)*)?
	body=XBlockExpression
;

XBlockExpression returns xbase::XExpression: 
	{XBlockExpression}
	'{'
		(expressions+=XExpressionInsideBlock ';'?)*
	'}';

XExpressionInsideBlock returns xbase::XExpression:
	XVariableDeclaration | 
	XPrimaryExpression |
	operandAssignment
	;


//attribute assignments
attributeAssignment:
	 assignType = (arrayAssignment | blockAssignment | multyAssignOperation| XConstructorCall)
;
//assignment with {...}
blockAssignment:
	{blockAssignment}
	"{" (values+=literal (',' values+=literal)*)? "}"
;
//square bracket assignment
arrayAssignment:
<<<<<<< Updated upstream
	{arrayAssignment}
	"new" (jType=abstractTypeName) arguments=squareClosure
;



//attribute declaration
attributeDeclaration :
	(visible=Visibility)? 'static'? jType=abstractTypeName
	name = declarativeID ('=' value=attributeAssignment)? 
;

//expression of the block
myBlockExpression returns xbase::XExpression:
	{myBlockExpression}
	'{'
		((expressions+=blockFeature))* 
		
	'}'
;
//features that are present in the block
blockFeature  returns xbase::XExpression :
 			(XVariableDeclaration ';' | 
 			 abstractAssignmentOperation ';' | 
 			 XPrimaryExpression ';'?|
			 jFaceSpecificLiteral
 			)
=======
	"new" (jType=abstractTypeName) arguments=ArryaBraketsWithAssignment
>>>>>>> Stashed changes
;
XAssignment returns xbase::XExpression:
	operandAssignment | unaryOperation
;

operandAssignment:
	result=simpleOperand valueAssignmentOperator
		value=multyAssignOperation
;

multyAssignOperation :

	operands+= (XFeatureCall | literal | XParenthesizedExpression) 
		(binaryOperator operands+=multyAssignOperation)*
	
;
unaryOperation:
	result=XFeatureCall
		operator=unaryOperator
	;

//removed =>, see what happens
conditionalExpression:
	
	('('operands+=operandAssignment')' 
		conditionOperator operands+=multyAssignOperation
	| operands+=multyAssignOperation
	 	(conditionOperator operands+=multyAssignOperation)?)
	
	(('&&' | '||')expressions+=conditionalExpression)*
;




<<<<<<< Updated upstream
XVariableDeclaration returns XExpression:
	jType=abstractTypeName
=======
XVariableDeclaration  returns xbase::XExpression:
{XVariableDeclaration}
	type=abstractTypeName
>>>>>>> Stashed changes
	name=declarativeID ('=' value = attributeAssignment)?
;
converssionCall:
	'('newJType=abstractTypeName')'name=XFeatureCall
	(arguments+=ArryaBraketsWithAssignment)?
;

calledParameter returns xbase::XExpression:
	
<<<<<<< Updated upstream
	(localMethodCall | simpleOperand | XConstructorCall | converssionCall) 
;

XFeatureCall returns XExpression:
	featureCalls+=calledParameter
	(('.' featureCalls+=calledParameter)*)
=======
	(localMethodCall | simpleOperand | XConstructorCall | converssionCall)
	//simpleOperand 
>>>>>>> Stashed changes
;

XFeatureCall returns xbase::XExpression:
	{XFeatureCall}
	('<' typeArguments+=JvmArgumentTypeReference (',' typeArguments+=JvmArgumentTypeReference)* '>')? 
	feature=[types::JvmIdentifiableElement|QualifiedName] 
	(=>explicitOperationCall?='(' 
		(
		    featureCallArguments+=XShortClosure
		  |	featureCallArguments+=XExpression (',' featureCallArguments+=XExpression)*
		)? 
	')')?
	featureCallArguments+=XClosure?;

//this is the call for a method; has multyAssignOp as parameter as it includes all.
localMethodCall:
	name = operandID '('
	(parameters+=multyAssignOperation (',' parameters+=multyAssignOperation)*)?
	')' (arguments+=ArryaBraketsWithAssignment)?
;
simpleOperand:
<<<<<<< Updated upstream
	name = operandID (arguments+=squareClosure)?
=======
	name = (operandID) 	
	(arguments+=ArryaBraketsWithAssignment)?
>>>>>>> Stashed changes
;

unaryOperator:
	"++" | "--"
;

binaryOperator:
	"+" | "-" | "*" | "/" 
;

conditionOperator:
	'==' | '!=' | '>=' | '<=' | '>' | '<' | 'instanceof'
	;
valueAssignmentOperator:
	"="|"+="|"-="
;


XIfExpression returns xbase::XExpression:
	{XIfExpression}
	'if' '(' if=conditionalExpression ')'
	then=XBlockExpression
	(=>'else' else=XBlockExpression)?;

XSwitchExpression returns xbase::XExpression:
	{XSwitchExpression}
	'switch' (=>(localVarName=typeID ':')? switch=XFeatureCall
		| =>('(' localVarName=typeID ':') switch=XFeatureCall ')') '{'
	(cases+=XCasePart 'break;')+
	('default' ':' defaultExp+=XExpressionInsideBlock* 'break;')?
	'}';

XCasePart:
	typeGuard=JvmTypeReference? ('case' case=XExpression)? 
		':' thenExp+=XExpressionInsideBlock
		 
		;
 
XForLoopExpression returns xbase::XExpression:
	
	classicForLoop | forLoopWithIterator
	;

classicForLoop:
	
	'for' '(' declaredParam=(XVariableDeclaration | simpleOperand) ';' 
				forExpression=conditionalExpression ';'
				forOperation=XAssignment ')'
		body=XBlockExpression
;

forLoopWithIterator:
	'for''('
		jType=(abstractTypeName) iteratorName=declarativeID ':'
		iteratableObject=XFeatureCall
		
	')'
	body=XBlockExpression
;



XWhileExpression returns xbase::XExpression:
	{XWhileExpression}
	'while' '(' predicate=conditionalExpression ')'
		body=XBlockExpression;
	
XDoWhileExpression returns xbase::XExpression:
	{XDoWhileExpression}
   'do'
       body=XBlockExpression
   'while' '(' predicate=conditionalExpression ')';

<<<<<<< Updated upstream
XConstructorCall returns XExpression:
=======

//TODO: replace ValidID to support abstract type creation
XConstructorCall returns xbase::XExpression:
>>>>>>> Stashed changes
	{XConstructorCall}
	'new' constructor=[types::JvmConstructor|abstractTypeName] 
	(=>'<' typeArguments+=abstractTypeName (',' typeArguments+=abstractTypeName)* '>')?
	(=>'(' 
		(
		    arguments+=(multyAssignOperation)
		    (',' arguments+=(multyAssignOperation))*
		)? 
	')')?
	arguments+=ArryaBraketsWithAssignment?;

XThrowExpression returns xbase::XExpression :
	{XThrowExpression} 'throw' expression=(simpleOperand|XConstructorCall);
	
XReturnExpression returns xbase::XExpression:
	{XReturnExpression} 'return' (=>expression=multyAssignOperation);
	
XTryCatchFinallyExpression returns xbase::XExpression:
	{XTryCatchFinallyExpression}
	'try' 
		expression=XBlockExpression
	(
		catchClauses+=XCatchClause+
		(=>'finally' finallyExpression=XBlockExpression)?
	|	'finally' finallyExpression=XBlockExpression
	);
	
XCatchClause :
	=>'catch' '(' param=parameter ')' expression=XBlockExpression;

XParenthesizedExpression returns xbase::XExpression:
	'(' multyAssignOperation ')';




enum Visibility :
	 protected | public | private
;

 typeID:
 		('${'ValidID 
<<<<<<< Updated upstream
			(=>':''elemType' '('ValidID')}' | '}'))
 		|(=>'${''elemType' '('ValidID')}')
=======
			(=>':''elemType' '('type=JvmTypeReference')}' | ArrayBrackets? '}'))
 		|(=>'${''elemType' '('type=JvmTypeReference')}')
>>>>>>> Stashed changes
 ;

declarativeID:
	 ValidID | jFaceVarID 
;

jFaceVarID :
	('${'ValidID 
		(=>':' ('freeName' '('ValidID')}' | 'iter''}' | 'newName' '('ValidID')}')))
	|(=>'${''freeName' '('ValidID')}') 
	|=> '${'ValidID'}'
;


operandID :
<<<<<<< Updated upstream
	 ValidID | ('${'ValidID ':''var''}') 
	 |=>'${'ValidID'}'
=======
	 
	name=[types::JvmIdentifiableElement|QualifiedName] 
	 | {operandID}
	 ('${' ValidID ':''var''}') 
	 |{operandID}=>'${'ValidID'}'
>>>>>>> Stashed changes
;

 
literal:
	value= (STRING | Number | booleanLiteral  )
;
booleanLiteral:
	'true' | 'false' | 'null'
;

jFaceSpecificLiteral:
	'${'type=('cursor'|'dollar'|'line_selection')'}'
;

<<<<<<< Updated upstream
abstractTypeName :
	(typeID|ValidID) '[]'?
;

/* 
annotation :
	
	'${cursor}' | '${dollar}'
		
;*/
=======
abstractTypeName:
	(typeID)
	|=>	type=JvmTypeReference
;

>>>>>>> Stashed changes
helpperClassAnnotation :
	'${' 'helper' '}' 
	class= entity 
	'${' 'endHelper' '}'
;

ArrayBrackets :
	'[]'
;
ArryaBraketsWithAssignment:
	'[' multyAssignOperation ']'
;
 