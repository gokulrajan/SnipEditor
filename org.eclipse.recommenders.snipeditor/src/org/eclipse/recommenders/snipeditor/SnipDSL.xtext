grammar org.eclipse.recommenders.snipeditor.SnipDSL with org.eclipse.xtext.xbase.Xbase 
import 'http://www.eclipse.org/xtext/xbase/Xbase' as xbase
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as types
import "http://www.eclipse.org/xtext/xbase/Xtype" as xtypes
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate snipDSL "http://www.eclipse.org/recommenders/snipeditor/SnipDSL"

domainmodel:
	importSection=XImportSection?
    (elements += abstractElement )*
;
XImportDeclaration returns xtypes::XImportDeclaration:
	'${''import''('
	(
	importedType=[types::JvmDeclaredType|QualifiedName] 
		| importedNamespace=QualifiedNameWithWildcard
	)
	')}'
;


abstractElement returns xbase::XExpression:
	packageDeclare | 
	entity | 
	feature | 
	helpperClassAnnotation | 
	XExpression ";"? |
	jFaceSpecificLiteral
;

packageDeclare:
	'package' name = QualifiedName '{'
	(elements += abstractElement)*
	'}'
;


entity:
	(visibility=Visibility)? 'class' name = ValidID 
		('extends' jType=abstractTypeName  )?
	'{'
		features += feature*
	
	'}'
;

feature returns xbase::XExpression:
	attributeDeclaration ";" | method 

;


parameter :
	(jType=abstractTypeName)  name = declarativeID;


method:
	(visibility=Visibility)? 'static'?  (jType=abstractTypeName | "void")
	name=ValidID'('(params+=parameter
		(','params+=parameter)*)?')' 
		('throws' throwExceptions+=operandID(',' throwExceptions+=operandID)*)?
	body=XBlockExpression
;
//attribute assignments
attributeAssignment returns xbase::XExpression:
	 blockAssignment | XLiteral |=>XExpression
;
//assignment with {...}
blockAssignment returns xbase::XExpression:
	{blockAssignment}
	"{" (values+=XLiteral (',' values+=XLiteral)*)? "}"
;


//attribute declaration
attributeDeclaration :
	(visible=Visibility)? 'static'? (jType=abstractTypeName)
	name = declarativeID ('=' value=XExpression)? 
;

//features that are present in the block
XExpressionInsideBlock  returns xbase::XExpression :
 			(XVariableDeclaration ';'| 
 			 XExpression ';'?| 
			 jFaceSpecificLiteral
 			) 
;


XVariableDeclaration returns xbase::XExpression:
	{xbase::XVariableDeclaration}
	//TODO: resolve assignment to final variables!
	( writeable?='final')? (type=abstractTypeName) name=declarativeID ('=' right=attributeAssignment)?;


XConstructorCall returns xbase::XExpression:
	{xbase::XConstructorCall}
	'new' constructor=[types::JvmConstructor|QualifiedName] 
	(=>'<' typeArguments+=JvmArgumentTypeReference (',' typeArguments+=JvmArgumentTypeReference)* '>')?
	((=>'(' 
		(
		    arguments+=XShortClosure
		  |	arguments+=XExpression (',' arguments+=XExpression)*
		)? 
	')') |=> arguments+=XClosure);

XClosure returns xbase::XExpression:
	=>({xbase::XClosure} 
	'[') 
		=>((declaredFormalParameters+=JvmFormalParameter (',' declaredFormalParameters+=JvmFormalParameter)*)? explicitSyntax?='|')? 
		expression=(XExpressionInClosure | XNumberLiteral)
	']';


enum Visibility :
	 protected | public | private
;

//TODO: put abstract type in elemType!
 typeID returns types::JvmTypeReference:
 		('${'ValidID':''elemType' '('=>JvmTypeReference')}')
 		|(=>'${''elemType' '('=>JvmTypeReference')}')
 ;

declarativeID:
	  jFaceVarID |
	  =>ValidID 
;

jFaceVarID:
	'${'=>ValidID'}' 
		|('{'=>ValidID':'('freeName'|'newName') '('ValidID')}')
 		|(=>'${'('freeName'|'newName') '('=>ValidID')}')
;
operandID :
	ValidID | 
	('${' (ValidID) (':''var')? '}') 
;


jFaceSpecificLiteral:
	'${'type=('cursor'|'dollar'|'line_selection')'}'
;

abstractTypeName returns types::JvmTypeReference:
	(typeID)  
	|=>	JvmTypeReference
;
FeatureCallID:
	operandID | 'extends' | 'static' | 'import' | 'extension'
;
JvmFormalParameter returns types::JvmFormalParameter:
	(parameterType=JvmTypeReference)? name=operandID;
	
FullJvmFormalParameter returns types::JvmFormalParameter:
	parameterType=JvmTypeReference (name=declarativeID |=>name=operandID) ;

/* 
annotation :
	
	'${cursor}' | '${dollar}'
		
;*/
helpperClassAnnotation :
	'${' 'helper' '}' 
	class= entity 
	'${' 'endHelper' '}'
;
XLiteral returns xbase::XExpression:
	XBooleanLiteral |
	XNumberLiteral |
	XNullLiteral |
	XStringLiteral
;
terminal ID:
	'^'? ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
	

 