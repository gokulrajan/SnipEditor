grammar org.eclipse.recommenders.snipeditor.SnipDSL with org.eclipse.xtext.xbase.Xbase 
import 'http://www.eclipse.org/xtext/xbase/Xbase' as xbase
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as types
import "http://www.eclipse.org/xtext/xbase/Xtype" as xtypes
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate snipDSL "http://www.eclipse.org/recommenders/snipeditor/SnipDSL"

domainmodel:
	importSection=XImportSection?
    (elements += abstractElement )*
;
XImportDeclaration returns xtypes::XImportDeclaration:
	'${''import''('
	(
	importedType=[types::JvmDeclaredType|QualifiedName] 
		| importedNamespace=QualifiedNameWithWildcard
	)
	')}'
;


abstractElement returns xbase::XExpression:
	packageDeclare | 
	entity | 
	feature | 
	helpperClassAnnotation | 
	abstractAssignmentOperation ";"? |
	jFaceSpecificLiteral
;

packageDeclare:
	'package' name = QualifiedName '{'
	(elements += abstractElement)*
	'}'
;


entity:
	(visibility=Visibility)? 'class' name = ValidID 
		('extends' jType=abstractTypeName  )?
	'{'
		features += feature*
	
	'}'
;

feature returns xbase::XExpression:
	attributeDeclaration ";" | method 

;


parameter :
	(jType=abstractTypeName)  name = declarativeID;


method:
	(visibility=Visibility)? 'static'?  (jType=abstractTypeName | "void")
	name=ValidID'('(params+=parameter
		(','params+=parameter)*)?')' 
		('throws' throwExceptions+=operandID(',' throwExceptions+=operandID)*)?
	body=XBlockExpression
;
//attribute assignments
attributeAssignment returns xbase::XExpression:
	 arrayAssignment | blockAssignment | XLiteral |=>XExpression
;
//assignment with {...}
blockAssignment returns xbase::XExpression:
	{blockAssignment}
	"{" (values+=XLiteral (',' values+=XLiteral)*)? "}"
;
//square bracket assignment
arrayAssignment returns xbase::XExpression:
	{arrayAssignment}
	"new" (jType=abstractTypeName) arguments=squareClosure
;



//attribute declaration
attributeDeclaration :
	(visible=Visibility)? 'static'? (jType=abstractTypeName)
	name = declarativeID ('=' value=XExpression)? 
;

//expression of the block

//features that are present in the block
XExpressionInsideBlock  returns xbase::XExpression :
 			(XVariableDeclaration ';' | 
 			 abstractAssignmentOperation ';'? | 
			 jFaceSpecificLiteral
 			)
;

abstractAssignmentOperation returns xbase::XExpression:
	XExpression | unaryOperation
;

/*multyAssignOperation :

	operands+= (XMemberFeatureCall | literal)
		(binaryOperator operands+=multyAssignOperation)*
	
;*/
unaryOperation:
	result=operandID
		operator=unaryOperator
	;

/*conditionalExpression:
	
	('('operands+=XAssignment')' 
		conditionOperator operands+=multyAssignOperation
	| operands+=multyAssignOperation
	 	(conditionOperator operands+=multyAssignOperation)?)
	
	(('&&' | '||')expressions+=conditionalExpression)*
;*/




XVariableDeclaration returns xbase::XExpression:
	{xbase::XVariableDeclaration}
	(writeable?='final')? type=abstractTypeName name=declarativeID ('=' right=attributeAssignment)?;


/*XMemberFeatureCall returns xbase::XExpression:
	XPrimaryExpression
	(=>({XAssignment.assignable=current} ('.'|explicitStatic?="::") feature=simpleOperand OpSingleAssign) value=XAssignment
	|=>({XMemberFeatureCall.memberCallTarget=current} ("."|nullSafe?="?."|explicitStatic?="::")) 
		('<' typeArguments+=JvmArgumentTypeReference (',' typeArguments+=JvmArgumentTypeReference)* '>')?  
		feature=simpleOperand (
			=>explicitOperationCall?='(' 
				(
				    memberCallArguments+=XShortClosure
				  |	memberCallArguments+=XExpression (',' memberCallArguments+=XExpression)*
				)? 
			')')?
			memberCallArguments+=XClosure?
		)*;
XFeatureCall returns XExpression:
	{XFeatureCall}
	('<' typeArguments+=JvmArgumentTypeReference (',' typeArguments+=JvmArgumentTypeReference)* '>')? 
	feature=simpleOperand 
	(=>explicitOperationCall?='(' 
		(
		    featureCallArguments+=XShortClosure
		  |	featureCallArguments+=XExpression (',' featureCallArguments+=XExpression)*
		)? 
	')')?
	featureCallArguments+=XClosure?;

*/


/*
converssionCall:
	'('newJType=abstractTypeName')'name=XFeatureCall
	(arguments+=squareClosure)?
;

calledParameter returns xbase::XExpression:
	
	(localMethodCall | simpleOperand | XConstructorCall | converssionCall) 
;
*/

//this is the call for a method; has multyAssignOp as parameter as it includes all.
/*localMethodCall:
	name = operandID '('
	(parameters+=multyAssignOperation (',' parameters+=multyAssignOperation)*)?
	')' (arguments+=squareClosure)?
;*/
/*simpleOperand:
	(operandID) 	
	(arguments+=squareClosure)?
;*/

unaryOperator:
	"++" | "--"
;
/*
binaryOperator:
	"+" | "-" | "*" | "/" 
;

conditionOperator:
	'==' | '!=' | '>=' | '<=' | '>' | '<' | 'instanceof'
	;*/
valueAssignmentOperator:
	"="|"+="|"-="
;
 
/*XForLoopExpression returns xbase::XExpression:
	
	classicForLoop | forLoopWithIterator
;

classicForLoop:
	
	'for' '(' declaredParam=operandID ';' 
				forExpression=XExpression ';'
				forOperation=abstractAssignmentOperation ')'
		body=XBlockExpression
;

forLoopWithIterator:
	'for''('
		jType=(abstractTypeName) iteratorName=declarativeID ':'
		iteratableObject=XExpression
		
	')'
	body=XBlockExpression
;

//TODO: replace ValidID to support abstract type creation
/*XConstructorCall returns xbase::XExpression:
	{XConstructorCall}
	'new' constructor=abstractTypeName 
	(=>'<' typeArguments+=abstractTypeName (',' typeArguments+=abstractTypeName)* '>')?
	(=>'(' 
		(
		    arguments+=XExpression
		    (',' arguments+=XExpression)*
		)? 
	')')?
	arguments+=squareClosure?;

XTryCatchFinallyExpression returns XExpression:
	{XTryCatchFinallyExpression}
	'try' 
		expression=XBlockExpression
	(
		catchClauses+=XCatchClause+
		(=>'finally' finallyExpression=XBlockExpression)?
	|	'finally' finallyExpression=XBlockExpression
	);
	
XCatchClause :
	=>'catch' '(' param=parameter ')' expression=XBlockExpression;

*/


enum Visibility :
	 protected | public | private
;

//TODO: put abstract type in elemType!
 typeID returns types::JvmTypeReference:
 		({typeID}'${'ValidID '}'
		|(=>'${'ValidID':''elemType' '('=>JvmTypeReference')}'))
 		|(=>'${''elemType' '('=>JvmTypeReference')}')
 ;

declarativeID:
	  jFaceVarID |
	  =>ValidID 
;

jFaceVarID:
	'${'=>ValidID'}' 
		|('{'=>ValidID':'('freeName'|'newName') '('ValidID')}')
 		|(=>'${'('freeName'|'newName') '('=>ValidID')}')
;
operandID returns types::JvmIdentifiableElement:
	{types::JvmIdentifiableElement}ValidID | 
	{types::JvmIdentifiableElement}('${' (ValidID) (':''var')? '}') 
;


jFaceSpecificLiteral:
	'${'type=('cursor'|'dollar'|'line_selection')'}'
;

abstractTypeName returns types::JvmTypeReference:
	(typeID) '[]'? 
	|=>	JvmTypeReference '[]'?
;



/* 
annotation :
	
	'${cursor}' | '${dollar}'
		
;*/
helpperClassAnnotation :
	'${' 'helper' '}' 
	class= entity 
	'${' 'endHelper' '}'
;
XLiteral returns xbase::XExpression:
	XBooleanLiteral |
	XNumberLiteral |
	XNullLiteral |
	XStringLiteral
;
squareClosure:
	'[' expression=XNumberLiteral ']'
;
 