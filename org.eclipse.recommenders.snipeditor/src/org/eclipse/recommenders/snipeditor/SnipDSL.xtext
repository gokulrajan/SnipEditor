grammar org.eclipse.recommenders.snipeditor.SnipDSL with org.eclipse.xtext.xbase.Xbase
import 'http://www.eclipse.org/xtext/xbase/Xbase' as xbase
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as types
generate snipDSL "http://www.eclipse.org/recommenders/snipeditor/SnipDSL"

domainmodel:
	importSection += (importDeclare)?
	elements += abstractElement*
	(annotations+=annotation*)?
;
importDeclare:
	'${import' '('name = (QualifiedNameWithWildcard | QualifiedName) ')}'
;


abstractElement returns xbase::XExpression:
	packageDeclare | entity | feature | blockFeature
;

packageDeclare:
	'package' name = QualifiedName '{'
	(elements += abstractElement)*
	'}'
;


entity:
	(visibility=Visibility)? 'class' name = ValidID 
		('extends' ( superType=JvmTypeReference | abstractTypeName  ) )?
	'{'
		features += feature*
		(annotations+=annotation*)?
	'}'
;

feature returns xbase::XExpression:
	attributeDeclaration | method 

;


parameter :
	(parameterType=JvmTypeReference | abstractTypeName)  name = declarativeID;


method:
	(visibility=Visibility)? 'static'?  (abstractTypeName | "void")
	name=ValidID'('(params+=parameter
		(','params+=parameter)*)?')'
	body=myBlockExpression
;

attributeAssignment returns xbase::XExpression:
	 arrayAssignment | blockAssignment | XConstructorCall | binaryOperation
;

blockAssignment:
	{blockAssignment}
	"{" (values+=literal (',' values+=literal)*)? "}"
;

arrayAssignment:
	{arrayAssignment}
	"new" (abstractTypeName | jType=JvmTypeReference)"[" (value=simpleOperand | Number) "]"
;


binaryOperation:
	'('?
	operands+= ( featureCall | literal) ')'?
		((binaryOperator operands+=binaryOperation)*) ?
	
;

attributeDeclaration :
	(visible=Visibility)? 'static'?   abstractTypeName '[]'?
	name = declarativeID ('=' value=attributeAssignment)? ";"
;


myBlockExpression returns xbase::XExpression:
	{myBlockExpression}
	'{'
		(expressions+=blockFeature)* 
		(annotations+=annotation*)?
	'}'
;

blockFeature returns xbase::XExpression:
 			(operandWithDeclaration ';' |  abstractOperation ';' | XPrimaryExpression ';'?
 				|  featureCall ';'
 			)
;

abstractOperation:
	operandAssignment | unaryOperation
;

operandAssignment:
	result=simpleOperand valueAssignmentOperator
		value=binaryOperation
;


unaryOperation:
	result=simpleOperand
		operator=unaryOperator
	;

conditionalExpression:
	operands+=simpleOperand (conditionOperator operands+=( featureCall | literal ))?
	((('&&' | '||')expressions+=conditionalExpression)*) ?
;




operandWithDeclaration returns operand:
	(abstractTypeName | jType = JvmTypeReference)
	name=declarativeID ('=' value = attributeAssignment)?
;


calledParameter returns xbase::XExpression:
	
	localMethodCall | simpleOperand | XConstructorCall
;

featureCall returns operand:
	featureCalls+=calledParameter
	(('.' featureCalls+=calledParameter)*)?
;

localMethodCall:
	name = declarativeID '('
	(parameters+=(featureCall | literal) (',' parameters+=(featureCall | literal))*)?
	')' 
;
simpleOperand returns operand:
	name = declarativeID
;

unaryOperator:
	"++" | "--"
;

binaryOperator:
	"+" | "-" | "*" | "/" 
;

conditionOperator:
	'==' | '!=' | '>=' | '<=' | '>' | '<'
	;
valueAssignmentOperator:
	"="|"+="|"-="
;


XIfExpression returns XExpression:
	{XIfExpression}
	'if' '(' if=conditionalExpression ')'
	then=myBlockExpression
	(=>'else' else=myBlockExpression)?;

XSwitchExpression returns XExpression:
	{XSwitchExpression}
	'switch' (=>(localVarName=typeID ':')? switch=featureCall
		| =>('(' localVarName=typeID ':') switch=featureCall ')') '{'
	(cases+=XCasePart)+
	('default' ':' default=operandAssignment )?
	'}';

XCasePart:
	typeGuard=JvmTypeReference? ('case' case=XExpression)? 
		':' then=myBlockExpression 
		;
 
XForLoopExpression returns XExpression:
	
	classicForLoop | forLoopWithIterator
	;

classicForLoop:
	
	'for' '(' declaredParam=(operandWithDeclaration | simpleOperand) ';' 
				forExpression=conditionalExpression ';'
				forOperation=abstractOperation ')'
		body=myBlockExpression
;

forLoopWithIterator:
	'for''('
		(abstractTypeName | jType = JvmTypeReference) iteratorName=declarativeID ':'
		iteratableObject=featureCall
		
	')'
	body=myBlockExpression
;



XWhileExpression returns XExpression:
	{XWhileExpression}
	'while' '(' predicate=conditionalExpression ')'
		body=myBlockExpression;
	
XDoWhileExpression returns XExpression:
	{XDoWhileExpression}
   'do'
       body=myBlockExpression
   'while' '(' predicate=conditionalExpression ')';



enum Visibility :
	 protected | public | private
;

 typeID:
 	'${' ( 
 		ValidID |
 		'elemType(' ValidID ')'
 		)
 	 '}' 
 ;

declarativeID:
	jFaceVarID | ValidID
;

jFaceVarID:
	'${' 
	(
		ValidID |
		'freeName('ValidID')' |
		ValidID ':' ('freeName('ValidID')' | 'iter')
	) 
	'}'
;



literal:
	value= (STRING | Number | booleanLiteral)
;
booleanLiteral:
	'true' | 'false' | 'null'
;

abstractTypeName:
	(typeID|ValidID)
;


annotation:
	
	'${helper}' | '${endHelper}' |
	'${cursor}' | '${dollar}'
		
;
 
 